# 1.分布式理论

### 1.分布式架构系统回顾

分布式系统的特点:
(1)分布性
(2)对等性
(3)并发性
(4)缺乏全局时钟
(5)故障总是会发生

### 2.分布式系统面临的问题

1)通信异常

2)网络分区

网络之间出现了网络不连通，但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成了若干个
孤立的区域，分布式系统就会出现局部小集群，在极端情况下，这些小集群会独立完成原本需要整个分布式系统才
能完成的功能，包括数据的事务处理，这就对分布式一致性提出非常大的挑战。


3)节点故障

4)三态

### 3.分布式理论：一致性

1、强一致性

2、弱一致性

3、单调读一致性

4、因果一致性

5、最终一致性

### 4.分布式理论：CAP定理

**CAP 定理** 

> 2000 年7月的时候，加州大学伯克利分校的Eric Brewer 教授提出了 CAP 猜想，2年后，被 来自于麻省理工 的Seth Gilbert 和 Nancy Lynch 从理论上证明了猜想的可能性，从此，CAP 定理正式在学术上成为了分布式 计算领域的公认定理。并深深的影响了分布式计算的发展。 

CAP 理论含义是，一个分布式系统不可能同时满足一致性(C:Consistency)，可用性(A: Availability)和分区容错 性(P:Partition tolerance)这三个基本需求，最多只能同时满足其中的2个。 

| 选项         |                                                              |
| ------------ | ------------------------------------------------------------ |
| C 一致性     | `分布式系统当中的一致性指的是所有节点的数据一致，或者说是所有副本的数据一致 ` |
| A 可用性     | Reads and writes always succeed. 也就是说系统一直可用，而且服务一直保持正常 |
| P 分区容错性 | `系统在遇到一些节点或者网络分区故障的时候，仍然能够提供满足一致性和可用性的服务 ` |

### 5.分布式理论：BASE 理论

**什么是BASE理论** 

BASE:全称:Basically Available(基本可用)，Soft state(软状态),和 Eventually consistent(最终一致性)三个 短语的缩写，来自 ebay 的架构师提出。 



BASE是对CAP中一致性和可用性权衡的结果，BASE理论的核心思想是:**即使无法做到强一致性，但每个应用都可 以根据自身业务特点，采用适当的方式来使系统达到最终一致性。** 

### 6.分布式事务

**事务的基本特性:** 

我们知道**事务有4个非常重要的特性**，即我们常说的(ACID)。 

**Atomicity(原子性):**是说事务是一个不可分割的整体，所有操作要么全做，要么全不做;只要事务中有一个操作 出错，回滚到事务开始前的状态的话，那么之前已经执行的所有操作都是无效的，都应该回滚到开始前的状态。 

**Consistency(一致性):**是说事务执行前后，数据从一个状态到另一个状态必须是一致的，比如A向B转账(A、 B的总金额就是一个一致性状态)，不可能出现A扣了钱，B却没收到的情况发生。 

**Isolation(隔离性):**多个并发事务之间相互隔离，不能互相干扰。关于事务的隔离性，可能不是特别好理解， 这里的并发事务是指两个事务操作了同一份数据的情况;而对于并发事务操作同一份数据的隔离性问题，则是要求 不能出现**脏读、幻读**的情况，即事务A不能读取事务B还没有提交的数据，或者在事务A读取数据进行更新操作时， 不允许事务B率先更新掉这条数据。而为了解决这个问题，常用的手段就是加锁了，对于数据库来说就是通过数据 库的相关锁机制来保证。 

**Durablity(持久性):**事务完成后，对数据库的更改是永久保存的。

**什么是分布式事务** 

其实分布式事务从实质上看与数据库事务的概念是一致的，既然是事务也就需要满足事务的基本特性(ACID)，只
是**分布式事务相对于本地事务而言其表现形式有很大的不同**

### 7.分布式理论：一致性协议2PC

**什么是 2PC**

2PC ( Two-Phase Commit缩写)即两阶段提交协议，是将整个事务流程分为两个阶段，准备阶段(Prepare phase)、提交阶段(commit phase)，2是指两个阶段，P是指准备阶段，C是指提交阶段。 

在计算机中部分关系数据库如Oracle、MySQL支持两阶段提交协议. 

![image-20200625142807496](https://tva1.sinaimg.cn/large/007S8ZIlly1gg4iq60by7j30o20i0tb8.jpg)

**两个阶段过程:** 

1. 准备阶段(Prepare phase):事务管理器给每个参与者发送Prepare消息，每个数据库参与者在本地执行事 务，并写本地的Undo/Redo日志，此时事务没有提交。 (Undo日志是记录修改前的数据，用于数据库回 滚，Redo日志是记录修改后的数据，用于提交事务后写入数 据文件) 
2. 提交阶段(commit phase):如果事务管理器收到了参与者的执行失败或者超时消息时，直接给每个参与者 发送回滚(Rollback)消息;否则，发送提交(Commit)消息;参与者根据事务管理器的指令执行提交或者回滚操 作，并释放事务处理过程中使用的锁资源。注意:必须在最后阶段释放锁资源。 



**2PC 优点缺点**

**优点**

原理简单，实现方便 

**缺点**

同步阻塞，单点问题，数据不一致，过于保守



### 8.分布式理论：一致性协议3PC

**什么是三阶段提交** 

3PC，全称 “three phase commit”，是 2PC 的改进版，将 2PC 的 “提交事务请求” 过程一分为二，共形成了由 CanCommit、PreCommit和doCommit三个阶段组成的事务处理协议。 

**2PC对比3PC** 

1.首先对于协调者和参与者都设置了超时机制(在2PC中，只有协调者拥有超时机制，即如果在一定时间内没有收 到参与者的消息则默认失败),主要是避免了参与者在长时间无法与协调者节点通讯(协调者挂掉了)的情况下，无 法释放资源的问题，因为参与者自身拥有超时机制会在超时后，自动进行本地commit从而进行释放资源。而这种 机制也侧面降低了整个事务的阻塞时间和范围。 2.通过CanCommit、PreCommit、DoCommit三个阶段的设 计，相较于2PC而言，多设置了一个缓冲阶段保证了在最后提交阶段之前各参与节点的状态是一致的 。 3.PreCommit是一个缓冲，保证了在最后提交阶段之前各参与节点的状态是一致的。 

问题:3PC协议并没有完全解决数据不一致问题。 

### 9.分布式理论：一致性算法Paxos

**什么是Paxos算法**

![image-20200625144403088](https://tva1.sinaimg.cn/large/007S8ZIlly1gg4j6v783oj31aa0k6tlp.jpg)

Paxos由Lamport于1998年在《The Part-Time Parliament》论文中首次公开，最初的描述使用希腊的一个小岛
Paxos作为比喻，描述了Paxos小岛中通过决议的流程，并以此命名这个算法，但是这个描述理解起来比较有挑战
性。后来在2001年，Lamport觉得同行不能理解他的幽默感，于是重新发表了朴实的算法描述版本《Paxos Made
Simple》

自Paxos问世以来就持续垄断了分布式一致性算法，Paxos这个名词几乎等同于分布式一致性。Google的很多大型 分布式系统都采用了Paxos算法来解决分布式一致性问题，如Chubby、Megastore以及Spanner等。开源的 ZooKeeper，以及MySQL 5.7推出的用来取代传统的主从复制的MySQL Group Replication等纷纷采用Paxos算法 解决分布式一致性问题。 

然而，Paxos的最大特点就是难，不仅难以理解，更难以实现。 



**Paxos 解决了什么问题** 

答:解决了分布式系统一致性问题。

```
分布式系统才用多副本进行存储数据 , 如果对多个副本执行序列不控制, 那多个副本执行更新操作,由于网络延迟 超时 等故障到值各个副本的数据不一致.
 我们希望每个副本的执行序列是 [ op1 op2 op3 .... opn ] 不变的, 相同的.
 Paxos 一次来确定不可变变量 opi的取值 , 每次确定完Opi之后,各个副本执行opi操作,一次类推。 

结论: Paxos算法需要解决的问题就是如何在一个可能发生上述异常的分布式系统中，快速且正确地在集群内部对某个 数据的值达成一致. 

注:这里某个数据的值并不只是狭义上的某个数，它可以是一条日志，也可以是一条命令(command)。。。根据应用场 景不同，某个数据的值有不同的含义 
```



**Paxos相关概念** 

首先一个很重要的概念叫提案(Proposal)。最终要达成一致的value就在提案里。

 提案 (Proposal):Proposal信息包括提案编号 (Proposal ID) 和提议的值 (Value) 

在Paxos算法中，有如下角色: 

- Client:客户端

  	 客户端向分布式系统发出 ，并等待 。例如，对分布式文件服务器中文件的写请求。 

- Proposer:提案发起者 

	提案者提倡客户请求，试图说服Acceptor对此达成一致，并在发生冲突时充当协调者以推动协议向前发 

展 

- Acceptor:决策者，可以批准提案 

	Acceptor可以接受(accept)提案;如果某个提案被选定(chosen)，那么该提案里的value就被选定 了 

- Learners:最终决策的学习者 

	学习者充当该协议的复制因素 



还真如网上说的目前关于paxos算法的介绍已经很多，但大多数是和稀泥式的人云亦云。（我觉得老师讲的也不是很清楚），网上查资料看了几个小时才有所明白。



### 10.分布式理论：一致性算法Raft

首先说什么是 Raft 算法:Raft 是一种为了管理复制日志的一致性算法。

 Raft提供了和Paxos算法相同的功能和性能，但是它的算法结构和Paxos不同。Raft算法更加容易理解并且更容易构 建实际的系统。 

Raft将一致性算法分解成了3模块 

1. 领导人选举 

2. 日志复制

3. 安全性 

Raft算法分为两个阶段，首先是选举过程，然后在选举出来的领导人带领进行正常操作，比如日志复制等。 

# 2.分布式系统设计策略

分布式系统本质是通过低廉的硬件攒在一起以获得更好的吞吐量、性能以及可用性等。
在分布式环境下，有几个问题是普遍关心的，我们称之为设计策略:

-   如何检测当前节点还活着?
-   如何保障高可用?
-   容错处理
-   负载均衡

### 1.心跳检测

### 2.高可用性设计

系统高可用性的常用设计模式包括三种:主备(Master-SLave)、互备(Active-Active)和集群(Cluster)模式。

### 3.容错性

容错顾名思义就是IT系统对于错误包容的能力 

容错的处理是保障分布式环境下相应系统的高可用或者健壮性，一个典型的案例就是对于缓存穿透 问题的解决方 案。 

我们在项目中使用缓存通常都是先检查缓存中是否存在，如果存在直接返回缓存内容，如果不存在就直接查询数据 库然后再缓存查询结果返回。这个时候如果我们查询的某一个数据在缓存中一直不存在，就会造成每一次请求都查 询DB，这样缓存就失去了意义，在流量大时，或者有人恶意攻击 

如频繁发起为id为“-1”的条件进行查询，可能DB就挂掉了。 

那这种问题有什么好办法解决呢?

一个比较巧妙的方法是，可以将这个不存在的key预先设定一个值。比如，key=“null”。在返回这个null值的时候， 我们的应用就可以认为这是不存在的key，那我们的应用就可以决定是否继续等待访问，还是放弃掉这次操作。如 果继续等待访问，过一个时间轮询点后，再次请求这个key，如果取到的值不再是null，则可以认为这时候key有值 了，从而避免了透传到数据库，把大量的类似请求挡在了缓存之中。 

### 4.负载均衡

负载均衡:其关键在于使用多台集群服务器共同分担计算任务，把网络请求及计算分配到集群可用的不同服务器节 

点上，从而达到高可用性及较好的用户操作体验。 

# 3.分布式架构网络通信

在分布式服务框架中，一个最基础的问题就是远程服务是怎么通讯的，在Java领域中有很多可实现远程通讯的技
术，例如:RMI、Hessian、SOAP、ESB和JMS等，它们背后到底是基于什么原理实现的呢

### 1.基本原理

要实现网络机器间的通讯，首先得来看看计算机系统网络通信的基本原理，在底层层面去看，网络通信需要做的就
是将流从一台计算机传输到另外一台计算机，基于传输协议和网络IO来实现，其中传输协议比较出名的有tcp、
udp等等，tcp、udp都是在基于Socket概念上为某类应用场景而扩展出的传输协议，网络IO，主要有bio、nio、
aio三种方式，所有的分布式应用通讯都基于这个原理而实现，只是为了应用的易用，各种语言通常都会提供一些
更为贴近应用易用的应用层协议。

**（通过不同的传输协议 + 网络IO的组合进行的远程调用）**

### 2.什么是RPC

RPC全称为remote procedure call，即远程过程调用。 

借助RPC可以做到像本地调用一样调用远程服务，是一种进程间的通信方式 

比如两台服务器A和B，A服务器上部署一个应用，B服务器上部署一个应用，A服务器上的应用想调用B服务器上的 应用提供的方法，由于两个应用不在一个内存空间，不能直接调用，所以需要通过网络来表达调用的语义和传达调 用的数据。 

需要注意的是RPC并不是一个具体的技术，而是指整个网络远程调用过程。 



RPC架构 

一个完整的RPC架构里面包含了四个核心的组件，分别是Client，Client Stub，Server以及Server Stub，这个Stub 可以理解为存根。 

- 客户端(Client)，服务的调用方。
-  客户端存根(Client Stub)，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远 程发送给服务方。
-  服务端(Server)，真正的服务提供者。
-  服务端存根(Server Stub)，接收客户端发送过来的消息，将消息解包，并调用本地的方法。 

### 3.RMI

**简介** 

Java RMI 指的是远程方法调用 (Remote Method Invocation),是java原生支持的远程调用 ,采用JRMP(Java Remote Messageing protocol)作为通信协议，可以认为是纯java版本的分布式远程调用解决方案， RMI主要用 于不同虚拟机之间的通信，这些虚拟机可以在不同的主机上、也可以在同一个主机上，这里的通信可以理解为一个 虚拟机上的对象调用另一个虚拟机上对象的方法。 



```
1.客户端:

 1)存根/桩(Stub):远程对象在客户端上的代理;

 2)远程引用层(Remote Reference Layer):解析并执行远程引用协议;

 3)传输层(Transport):发送调用、传递远程方法参数、接收远程方法执行结果。 
```

```
2.服务端: 

1)骨架(Skeleton):读取客户端传递的方法参数，调用服务器方的实际对象方法， 并接收方法执行后的返回值;

2)远程引用层(Remote Reference Layer):处理远程引用后向骨架发送远程方法调用; 

3)传输层(Transport):监听客户端的入站连接，接收并转发调用到远程引用层 
```

**开发流程**

```
1.服务端:

1)定义Remote子接口，在其内部定义要发布的远程方法，并且这些方法都要Throws RemoteException;
2)定义实现远程接口，并且继承:UnicastRemoteObject
3)启动服务器:依次完成注册表的启动和远程对象绑定。
```

```
2.客户端:

1)通过符合JRMP规范的URL字符串在注册表中获取并强转成Remote子接口对象;
2)调用这个Remote子接口对象中的某个方法就是为一次远程方法调用行为。
```



### 4.BIO , NIO ,AIO

**同步和异步**

同步(synchronize)、异步(asychronize)是指应用程序和内核的交互而言的.

 同步: 

指用户进程触发IO操作等待或者轮训的方式查看IO操作是否就绪。 

```
同步举例: 
银行取钱,我自己去取钱,取钱的过程中等待. 
```

异步:

当一个异步进程调用发出之后，调用者不会立刻得到结果。而是在调用发出之后，被调用者通过状态、通知来通知
调用者，或者通过回调函数来处理这个调用。

使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS，OS需要支持异步IO操作 

```
举个例子:
异步举例: 我请朋友帮我取钱,他取到钱后返回给我. (委托给操作系统OS, OS需要支持IO异步API)
```

**阻塞和非阻塞** 

阻塞和非阻塞是针对于进程访问数据的时候,根据IO操作的就绪状态来采取不同的方式. 

简单点说就是一种读写操作方法的实现方式. 阻塞方式下读取和写入将一直等待, 而非阻塞方式下,读取和写入方法 会理解返回一个状态值. 



```
举个例子: 

阻塞: 

ATM机排队取款，你只能等待排队取款(使用阻塞IO的时候，Java调用会一直阻塞到读写完成才返回。) 

非阻塞: 

柜台取款，取个号，然后坐在椅子上做其他事，等广播通知，没到你的号你就不能去，但你可以不断的问大堂经理 排到了没有。(使用非阻塞IO时，如果不能读写Java调用会马上返回，当IO事件分发器会通知可读写时再继续进行 读写，不断循环直到读写完成) 
```



```
例子 

老张煮开水。 老张，水壶两把(普通水壶，简称水壶;会响的水壶，简称响水壶)。
1 老张把水壶放到火上，站立着等水开。(同步阻塞)
2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。(同步非阻塞) 
3 老张把响水壶放到火上，立等水开。(异步阻塞) 
4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。(异步非阻塞) 
```



**BIO**

同步阻塞IO。B代表blocking 服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连 

接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。 适用场景:Java1.4之前唯一的选择，简单易用但资源开销太高 



**NIO**

**1.NIO介绍**

同步非阻塞IO (non-blocking IO / new io)是指JDK 1.4 及以上版本。 

服务器实现模式为一个请求一个通道，即客户端发送的连接请求都会注册到多路复用器上，**多路复用器**轮询到连接 

有IO请求时才启动一个线程进行处理。 

**通道(Channels)** 

NIO 新引入的最重要的抽象是通道的概念。Channel 数据连接的通道。 数据可以从Channel读到Buffer中，也可以 从Buffer 写到Channel中 . 

**缓冲区(Buffers)** 

通道channel可以向缓冲区Buffer中写数据，也可以像buffer中存数据。

 **选择器(Selector)，也叫多路复用器**

 使用选择器，借助单一线程，就可对数量庞大的活动 I/O 通道实时监控和维护。 

**2.特点**

当一个连接创建后，不会需要对应一个线程，这个连接会被注册到多路复用器，所以一个连接只需要一个线程即
可，所有的连接需要一个线程就可以操作，该线程的多路复用器会轮训，发现连接有请求时，才开启一个线程处
理。

如上图所示，IO模型中，一个连接来了，会创建一个线程，对应一个while死循环，死循环的目的就是不断监测这 条连接上是否有数据可以读，大多数情况下，1w个连接里面同一时刻只有少量的连接有数据可读，因此，很多个 while死循环都白白浪费掉了，因为读不出啥数据。 

而在NIO模型中，他把这么多while死循环变成一个死循环，这个死循环由一个线程控制，那么他又是如何做到一 个线程，一个while死循环就能监测1w个连接是否有数据可读的呢? 这就是NIO模型中selector的作用，一条连接 来了之后，现在不创建一个while死循环去监听是否有数据可读了，而是直接把这条连接注册到selector上，然后， 通过检查这个selector，就可以批量监测出有数据可读的连接，进而读取数据，下面我再举个非常简单的生活中的 例子说明IO与NIO的区别 



```
在一家幼儿园里，小朋友有上厕所的需求，小朋友都太小以至于你要问他要不要上厕所，他才会告诉你。幼儿园一
共有100个小朋友，有两种方案可以解决小朋友上厕所的问题:



\1. 每个小朋友配一个老师。每个老师隔段时间询问小朋友是否要上厕所，如果要上，就领他去厕所，100个小朋友就需要 100个老师来询问，并且每个小朋友上厕所的时候都需要一个老师领着他去上，这就是IO模型，一个连接对应一个线程。 

\2. 所有的小朋友都配同一个老师。这个老师隔段时间询问所有的小朋友是否有人要上厕所，然后每一时刻把所有要上厕所 的小朋友批量领到厕所，这就是NIO模型，所有小朋友都注册到同一个老师，对应的就是所有的连接都注册到一个线程，然 后批量轮询。
```

**AIO**

异步非阻塞IO。A代表asynchronize 当有流可以读时,操作系统会将可以读的流传入read方法的缓冲区,并通知应用程序,对于写操作,OS将write方法的流 

写入完毕是操作系统会主动通知应用程序。因此read和write都是异步 的，完成后会调用回调函数。 使用场景:连接数目多且连接比较长(重操作)的架构，比如相册服务器。重点调用了OS参与并发操作，编程比 

较复杂。Java7开始支持 

### 5.Netty

**1.Netty认识**

Netty 是由 JBOSS 提供一个异步的、 基于事件驱动的网络编程框架。 

Netty 可以帮助你快速、 简单的开发出一 个网络应用， 相当于简化和流程化了 NIO 的开发过程。 作为当前最流行 的 NIO 框架， Netty 在互联网领域、 大数据分布式计算领域、 游戏行业、 通信行业等获得了广泛的应用， 知名 的 Elasticsearch 、 Dubbo 框架内部都采用了 Netty。 

![image-20200626125912096](https://tva1.sinaimg.cn/large/007S8ZIlly1gg5lrycj8yj315s0mcn5g.jpg)

**为什么使用Netty**

**NIO缺点**

1. NIO 的类库和 API 繁杂，使用麻烦。你需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、 ByteBuffer 等. 
2. 可靠性不强，开发工作量和难度都非常大
3. NIO 的 Bug。例如 Epoll Bug，它会导致 Selector 空轮询，最终导致 CPU 100%。

**Netty优点**

1. 对各种传输协议提供统一的 API
2. 高度可定制的线程模型——单线程、一个或多个线程池 
3. 更好的吞吐量，更低的等待延迟

4. 更少的资源消耗 
5. 最小化不必要的内存拷贝 



1. 单线程模型

   ![image-20200626132450066](https://tva1.sinaimg.cn/large/007S8ZIlly1gg5mipp7mnj314k0awgn5.jpg)

2. 线程池模型

   ![image-20200626132556814](https://tva1.sinaimg.cn/large/007S8ZIlly1gg5mjrrg6qj315k0i076x.jpg)

3. Netty 模型

   ![image-20200626132631556](https://tva1.sinaimg.cn/large/007S8ZIlly1gg5mkdupynj31500qiwju.jpg)

   Netty 抽象出两组线程池， BossGroup 专门负责接收客 户端连接， WorkerGroup 专门负责网络读写操作。
   NioEventLoop 表示一个不断循环执行处理 任务的线程， 每个 NioEventLoop 都有一个 selector， 用于监听绑定在其上的 socket 网络通道。 NioEventLoop 内部采用串行化设计， 从消息的读取->解码->处理->编码->发送， 始终由 IO 线 程 NioEventLoop 负责。


**Netty核心组件**

**ChannelHandler 及其实现类** 

ChannelHandler 接口定义了许多事件处理的方法， 我们可以通过重写这些方法去实现具 体的业务逻辑 

我们经常需要自定义一个 Handler 类去继承 ChannelInboundHandlerAdapter， 然后通过 重写相应方法实现业 务逻辑， 我们接下来看看一般都需要重写哪些方法: 

```
- public void channelActive(ChannelHandlerContext ctx)， 通道就绪事件 
- public void -channelRead(ChannelHandlerContext ctx, Object msg)， 通道读取数据事件 
- public void channelReadComplete(ChannelHandlerContext ctx) ， 数据读取完毕事件 
- public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)， 通道发生异常事件
```

**ChannelPipeline**

```
- ChannelPipeline 是一个 Handler 的集合， 它负责处理和拦截 inbound 或者 outbound 的事 件和操作， 相当于一个贯穿 Netty 的链。
- ChannelPipeline addFirst(ChannelHandler... handlers)， 把一个业务处理类(handler) 添加到链中的第一 个位置 - ChannelPipeline addLast(ChannelHandler... handlers)， 把一个业务处理类(handler) 添加到链中的最后 一个位置
```

![image-20200626133402997](https://tva1.sinaimg.cn/large/007S8ZIlly1gg5ms7oivfj31760howsa.jpg)

**ChannelHandlerContext**

这 是 事 件 处 理 器 上 下 文 对 象 ， Pipeline 链 中 的 实 际 处 理 节 点 。 每 个 处 理 节 点
ChannelHandlerContext 中 包 含 一 个 具 体 的 事 件 处 理 器 ChannelHandler ， 同 时
ChannelHandlerContext 中也绑定了对应的 pipeline 和 Channel 的信息，方便对 ChannelHandler 进行调用。
常用方法如下所示

```
/- ChannelFuture close()， 关闭通道 
/- ChannelOutboundInvoker flush()， 刷新
/- ChannelFuture writeAndFlush(Object msg) ， 将 数 据 写 到 ChannelPipeline 中 当 前 
/- ChannelHandler 的下一个 ChannelHandler 开始处理(出站)
```

**ChannelFuture**

表示 Channel 中异步 I/O 操作的结果， 在 Netty 中所有的 I/O 操作都是异步的， I/O 的调 用会直接返回， 调用者并不能立刻获得结果， 但是可以通过 ChannelFuture 来获取 I/O 操作 的处理状态。 常用方法如下所示:

```
Channel channel()， 返回当前正在进行 IO 操作的通道
ChannelFuture sync()， 等待异步操作执行完毕
```

**EventLoopGroup 和其实现类 NioEventLoopGroup**

EventLoopGroup 是一组 EventLoop 的抽象， Netty 为了更好的利用多核 CPU 资源， 一般 会有多个 EventLoop
同时工作， 每个 EventLoop 维护着一个 Selector 实例。 EventLoopGroup 提供 next 接口， 可以从组里面按照一定规则获取其中一个 EventLoop 来处理任务。 在 Netty 服务器端编程中， 我们一般都需要提供两个
EventLoopGroup， 例如: BossEventLoopGroup 和 WorkerEventLoopGroup。

```
/- public NioEventLoopGroup()， 构造方法 
/- public Future<?> shutdownGracefully()， 断开连接， 关闭线程
```

**ServerBootstrap 和 Bootstrap** 

ServerBootstrap 是 Netty 中的服务器端启动助手，通过它可以完成服务器端的各种配置; Bootstrap 是 Netty 中 

的客户端启动助手， 通过它可以完成客户端的各种配置。 常用方法如下 所示: 

```
- public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)，该方法用于 服务器端， 用来设置两个 EventLoop
- public B group(EventLoopGroup group) ， 该方法用于客户端， 用来设置一个 EventLoop
- public B channel(Class<? extends C> channelClass)， 该方法用来设置一个服务器端的通道实现 
- public <T> B option(ChannelOption<T> option, T value)， 用来给 ServerChannel 添加配置
- public <T> ServerBootstrap childOption(ChannelOption<T> childOption, T value)， 用来给接收到的 通道添加配置
- public ServerBootstrap childHandler(ChannelHandler childHandler)， 该方法用来设置业务处理类(自定 义的 handler)
- public ChannelFuture bind(int inetPort) ， 该方法用于服务器端， 用来设置占用的端口号
- public ChannelFuture connect(String inetHost, int inetPort) 该方法用于客户端， 用来连接服务器端 
```



### 6.基于Netty自定义RPC